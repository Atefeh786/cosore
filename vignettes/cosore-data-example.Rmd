---
title: "Working with COSORE data"
author: "Ben Bond-Lamberty"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
%\VignetteIndexEntry{Working with COSORE data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  ---
  
  ```{r setup, include = FALSE}
knitr::opts_chunk$set(
echo = TRUE,
collapse = TRUE,
comment = "#>"
)
```

# Introduction

TODO. 

```r
cosore <- readRDS("cosore_date.RDS")
```

```{r, echo=FALSE}
# For the vignette, we just read from the drake cache, not use readRDS as above
cosore <- drake::readd("all")
```

The `cosore` data are structured as a two-level nested list of data frames:

```
cosore
|- dataset 1
|   |- description table (a data.frame)
|   |- contributors table (same...)
|   |- ports table
|   |- columns table
|   |- ancillary table
|   |- data table
|   |- diagnostics table
|- dataset 2
|   |- description table
|   |- contributors table
|   |- ports table
|   |- columns table
|   |- ancillary table
|   |- data table
|   |- diagnostics table
|- dataset 3
|   |- etc.
```

For most analyses we want to extract one or more of these pieces and combine them--for example, to get a single table of contributors. There are [various](https://cran.r-project.org/package=purrr) [packages](https://cran.r-project.org/package=rlist) for dealing with nested lists, but we can also write our own short extractor function:

```{r extractor, echo=TRUE}
csr_table <- function(cosore, table_name) {
  
  extract <- function(x, table_name) {
    if(is.null(x[[table_name]])) { return(NULL) }
    # Add an identifier field so we can track things as tables get combined
    x[[table_name]]$CSR_DATASET <- x$description$CSR_DATASET
    x[[table_name]]
  }
  
  dplyr::bind_rows(lapply(cosore, extract, table_name = table_name))
}
```

With this in place, we extract a combined `description` table for the entire database and take a look at it:

```{r description-table}
desc <- csr_table(cosore, "description")
tibble::glimpse(desc)
```

Lots of information! (Note much of this is summarized in the `Report-all.html` file included with the data download.) But let's start with a single dataset and work our way up to multi-data analyses.

# Exploring a single dataset

To begin, we pick a single dataset (`d20190415_VARNER`), get some information about it, and plot it.

```{r desc-varner}
varner <- cosore$d20190415_VARNER
tibble::glimpse(varner$description)
```

The `description` table gives the basic information about this dataset: where it was measured,
the time zone that the `data` table timestamps are in, instrument used, and citation and acknowledgment information.

```{r sr-varner}
sr <- varner$data
nrow(sr)
summary(sr)
```

This dataset has `r nrow(sr)` observations; extends from April 2003 to December 2006; and soil respiration was measured on eight ports, along with air and 5 cm soil temperature. Visualize it:

```{r visualize-varner}
library(ggplot2)
ggplot(sr, aes(CSR_TIMESTAMP, CSR_FLUX, color = CSR_PORT)) +
  geom_point() + ggtitle("Flux over time")
library(lubridate, warn.conflicts = FALSE)
ggplot(sr, aes(CSR_T5, CSR_FLUX)) + facet_wrap(~month(CSR_TIMESTAMP), scales = "free") +
  geom_point() + ggtitle("5 cm soil temp vs. flux, by month")
```

Did these eight different ports (chambers) represent different treatments? We might want to 
exclude treatment collars, or color them differently in the plots above.

```{r ports-varner}
varner$ports
```

From this we see that the only `Port` entry is zero, with `Treatment` of "None", i.e. all ports/collars had the same treatment, and there _wasn't_ any treatment. Also, the collars were 1886 cm2.

Finally, we can use the `description` table information to get a full citation:

```{r pub-varner}
doi <- varner$description$Primary_pub
print(doi)
library(rcrossref)
cr_cn(dois = doi, format = "text")
```

# Selecting and combining multiple datasets

Time for something more ambitious.
